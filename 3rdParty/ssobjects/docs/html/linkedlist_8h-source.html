<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>linkedlist.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.7 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>linkedlist.h</h1><a href="linkedlist_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/********************************************************************</font>
00002 <font class="comment">        Copyright (c) 2001, Lee Patterson &amp; Ant Works Software</font>
00003 <font class="comment"></font>
00004 <font class="comment">        created  :  3/20/2000 1:00am</font>
00005 <font class="comment">        filename :  linkedlist.hpp</font>
00006 <font class="comment">        author   :  Lee Patterson (lee@antws.com)</font>
00007 <font class="comment">        </font>
00008 <font class="comment">        purpose  :  Template double linked list class for storing any type of data</font>
00009 <font class="comment"></font>
00010 <font class="comment">        notes    :  A linked list is either a master list, or a copy of a list. A</font>
00011 <font class="comment">                    master list is the original list. A copy is a copy of the</font>
00012 <font class="comment">                    master. A copied list points to the same data, but you can</font>
00013 <font class="comment">                    travers the copy and not mess up the position information of</font>
00014 <font class="comment">                    the master list. A copy should be treated as a read only</font>
00015 <font class="comment">                    version of the master. You are able to force a copy to be a</font>
00016 <font class="comment">                    master using forceMasterList() and clearMasterList methods;</font>
00017 <font class="comment">                    if in the case of the master being only a temporary list</font>
00018 <font class="comment">                    being passed to a method call, and this method call needs to</font>
00019 <font class="comment">                    keep a copy of the list. Use this feature carefully!</font>
00020 <font class="comment"></font>
00021 <font class="comment">                    The following actions are NOT allowed to be performed on a</font>
00022 <font class="comment">                    copied list:</font>
00023 <font class="comment"></font>
00024 <font class="comment">                    1) You are not allowed to remove the data that the list</font>
00025 <font class="comment">                       points to. Use empty() instead of purge() to clear the</font>
00026 <font class="comment">                       copied list. The LinkedList destructor knows when to purge or</font>
00027 <font class="comment">                       empty the list.</font>
00028 <font class="comment"></font>
00029 <font class="comment">                    2) You are not allowed to add items to the list. Since this</font>
00030 <font class="comment">                       is a copy, a purge() call will not work, and you will end</font>
00031 <font class="comment">                       up with memory leaks.</font>
00032 <font class="comment"></font>
00033 <font class="comment">                    You ARE allowed to remove items in the list, as this does</font>
00034 <font class="comment">                    not delete the data pointed to by the list. This is allowed</font>
00035 <font class="comment">                    so you are able to for example, as a check list, remove</font>
00036 <font class="comment">                    things from the list that have been worked with or</font>
00037 <font class="comment">                    completed. Be aware that if you delete the items returned by</font>
00038 <font class="comment">                    the remove methods, the master list will still point to the</font>
00039 <font class="comment">                    data you just deleted.</font>
00040 <font class="comment"></font>
00041 <font class="comment">*********************************************************************/</font>
00042 <font class="comment">//TODO: RemoveHead and removeTail need to reassign the current pointer</font>
00043 <font class="comment">//TODO  when the current pointer is at the head or tail. See removeCurrent()</font>
00044 
00045 <font class="preprocessor">#ifndef LINKEDLIST_H</font>
<a name="l00046"></a><a class="code" href="linkedlist_8h.html#a0">00046</a> <font class="preprocessor"></font><font class="preprocessor">#define LINKEDLIST_H</font>
00047 <font class="preprocessor"></font>
00048 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00049 <font class="preprocessor">#include &lt;assert.h&gt;</font>
00050 
00051 <font class="keyword">namespace </font>ssobjects
00052 {
00053 
<a name="l00054"></a><a class="code" href="classssobjects_1_1ListNode.html">00054</a> <font class="keyword">class </font>ListNode
00055 {
00056     <font class="keyword">public</font>: <font class="comment">//methods</font>
<a name="l00057"></a><a class="code" href="classssobjects_1_1ListNode.html#a0">00057</a>         <a class="code" href="classssobjects_1_1ListNode.html#a0">ListNode</a>() :
00058           m_pvItem(NULL),<font class="comment">/*m_pHead(NULL),m_pTail(NULL),*/</font>m_pPrev(NULL),m_pNext(NULL),m_pCurrent(NULL),m_id(0) {}
00059     <font class="keyword">public</font>: <font class="comment">//attributes</font>
<a name="l00060"></a><a class="code" href="classssobjects_1_1ListNode.html#m0">00060</a>         <font class="keywordtype">void</font>*   m_pvItem;
00061 <font class="comment">//        ListNode* m_pHead;</font>
00062 <font class="comment">//        ListNode* m_pTail;</font>
<a name="l00063"></a><a class="code" href="classssobjects_1_1ListNode.html#m1">00063</a>         ListNode* m_pPrev;
<a name="l00064"></a><a class="code" href="classssobjects_1_1ListNode.html#m2">00064</a>         ListNode* m_pNext;
<a name="l00065"></a><a class="code" href="classssobjects_1_1ListNode.html#m3">00065</a>         ListNode* m_pCurrent;
<a name="l00066"></a><a class="code" href="classssobjects_1_1ListNode.html#m4">00066</a>         <font class="keywordtype">int</font> m_id;
00067 
00068     <font class="keyword">private</font>:
00069         <font class="comment">//unused overloads</font>
00070         <a class="code" href="classssobjects_1_1ListNode.html#a0">ListNode</a>(<font class="keyword">const</font> ListNode&amp;);
00071         ListNode&amp; operator=(<font class="keyword">const</font> ListNode&amp;);
00072 };
00073 
<a name="l00074"></a><a class="code" href="namespace__ssobjects.html#a8">00074</a> <font class="keyword">enum</font> ListDirection {listPREV,listNEXT};
00075 
00076 template &lt;class T&gt;
<a name="l00077"></a><a class="code" href="classssobjects_1_1LinkedList.html">00077</a> <font class="keyword">class </font>LinkedList
00078 {
00079   <font class="keyword">protected</font>:
<a name="l00080"></a><a class="code" href="classssobjects_1_1LinkedList.html#n0">00080</a>     <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> m_nNumEntries;
<a name="l00081"></a><a class="code" href="classssobjects_1_1LinkedList.html#n1">00081</a>     <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> m_uniqueID;
<a name="l00082"></a><a class="code" href="classssobjects_1_1LinkedList.html#n2">00082</a>     ListNode* m_pHead;
<a name="l00083"></a><a class="code" href="classssobjects_1_1LinkedList.html#n3">00083</a>     ListNode* m_pTail;
<a name="l00084"></a><a class="code" href="classssobjects_1_1LinkedList.html#n4">00084</a>     ListNode* m_pCurrent;
00085 
00086     <font class="comment">// When m_bMasterList is NOT set, this is a copy of a list. As such, only list</font>
00087     <font class="comment">// attribues should be modified. The data that the list points to should not</font>
00088     <font class="comment">// be modified, as the master list should take care of that.</font>
<a name="l00089"></a><a class="code" href="classssobjects_1_1LinkedList.html#n5">00089</a>     <font class="keywordtype">bool</font> m_bMasterList;
00090 
00091   <font class="keyword">public</font>:
00092     <a class="code" href="classssobjects_1_1LinkedList.html#a0">LinkedList</a>();
00093     <a class="code" href="classssobjects_1_1LinkedList.html#a1">~LinkedList</a>();
00094 
<a name="l00095"></a><a class="code" href="classssobjects_1_1LinkedList.html#a2">00095</a>     <a class="code" href="classssobjects_1_1LinkedList.html#a0">LinkedList</a>(<font class="keyword">const</font> LinkedList&amp; l)
00096       : <a class="code" href="classssobjects_1_1LinkedList.html#n0">m_nNumEntries</a>(l.m_nNumEntries),
00097         <a class="code" href="classssobjects_1_1LinkedList.html#n1">m_uniqueID</a>(l.m_uniqueID),
00098         <a class="code" href="classssobjects_1_1LinkedList.html#n2">m_pHead</a>(NULL),
00099         <a class="code" href="classssobjects_1_1LinkedList.html#n3">m_pTail</a>(NULL),
00100         <a class="code" href="classssobjects_1_1LinkedList.html#n4">m_pCurrent</a>(NULL),
00101         <a class="code" href="classssobjects_1_1LinkedList.html#n5">m_bMasterList</a>(<font class="keyword">false</font>)<font class="keyword"></font>
00102 <font class="keyword">    </font>{
00103       <font class="comment">//make a copy of the list</font>
00104       <font class="keywordflow">if</font>(l.m_nNumEntries)
00105       {
00106         ListNode* pCurrentNode = l.m_pHead;
00107 
00108         <font class="comment">//get the head item of the list</font>
00109         ListNode* pHeadNode = <font class="keyword">new</font> ListNode;
00110         pHeadNode-&gt;m_pvItem = pCurrentNode-&gt;m_pvItem;
00111         m_pHead = m_pTail = m_pCurrent = pHeadNode;
00112 
00113         <font class="comment">//get the rest of the items in the list</font>
00114         ListNode* pPrevNode = pHeadNode;
00115         <font class="keywordflow">while</font>((pCurrentNode = pCurrentNode-&gt;m_pNext))
00116         {
00117           ListNode* pNewNode = <font class="keyword">new</font> ListNode;
00118           pNewNode-&gt;m_pPrev = pPrevNode;
00119           pNewNode-&gt;m_pvItem = pCurrentNode-&gt;m_pvItem;
00120 
00121           <font class="comment">// figure out if we are on the current node</font>
00122           <font class="keywordflow">if</font>(l.m_pCurrent  == pCurrentNode)
00123             m_pCurrent = pNewNode;
00124 
00125           pPrevNode-&gt;m_pNext = pNewNode;
00126           pPrevNode = pNewNode;
00127 
00128           m_pTail = pNewNode;
00129         }
00130       }
00131     }
00132 
<a name="l00133"></a><a class="code" href="classssobjects_1_1LinkedList.html#a3">00133</a>     LinkedList&amp; <a class="code" href="classssobjects_1_1LinkedList.html#a3">operator=</a>(<font class="keyword">const</font> LinkedList&amp; l)<font class="keyword"></font>
00134 <font class="keyword">    </font>{
00135       <font class="keywordflow">if</font>(&amp;l==<font class="keyword">this</font>)        <font class="comment">//object assigned to itself</font>
00136         <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00137 
00138       <a class="code" href="classssobjects_1_1LinkedList.html#a9">purge</a>();
00139       m_nNumEntries = l.m_nNumEntries;
00140       m_uniqueID    = l.m_uniqueID;   <font class="comment">//TODO: we should probably make this unique. should have a static id and thread safe if</font>
00141 
00142       m_pHead = m_pTail = m_pCurrent = NULL;
00143       m_bMasterList = <font class="keyword">false</font>;
00144 
00145       <font class="comment">//make a copy of the list</font>
00146       <font class="keywordflow">if</font>(l.m_nNumEntries)
00147       {
00148         ListNode* pCurrentNode = l.m_pHead;
00149 
00150         <font class="comment">//get the head item of the list</font>
00151         ListNode* pHeadNode = <font class="keyword">new</font> ListNode;
00152         pHeadNode-&gt;m_pvItem = pCurrentNode-&gt;m_pvItem;
00153         m_pHead = m_pTail = m_pCurrent = pHeadNode;
00154 
00155         <font class="comment">//get the rest of the items in the list</font>
00156         ListNode* pPrevNode = pHeadNode;
00157         <font class="keywordflow">while</font>((pCurrentNode = pCurrentNode-&gt;m_pNext))
00158         {
00159           ListNode* pNewNode = <font class="keyword">new</font> ListNode;
00160           pNewNode-&gt;m_pPrev = pPrevNode;
00161           pNewNode-&gt;m_pvItem = pCurrentNode-&gt;m_pvItem;
00162 
00163           <font class="comment">// figure out if we are on the current node</font>
00164           <font class="keywordflow">if</font>(l.m_pCurrent  == pCurrentNode)
00165             m_pCurrent = pNewNode;
00166 
00167           pPrevNode-&gt;m_pNext = pNewNode;
00168           pPrevNode = pNewNode;
00169 
00170           m_pTail = pNewNode;
00171         }
00172       }
00173       <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00174     }
00175 
00176     <font class="comment">// See comments in notes section above when using these methods. They are</font>
00177     <font class="comment">// not be used casually.</font>
<a name="l00178"></a><a class="code" href="classssobjects_1_1LinkedList.html#a4">00178</a>     <font class="keywordtype">void</font> <a class="code" href="classssobjects_1_1LinkedList.html#a4">forceMasterList</a>()<font class="keyword"> </font>{m_bMasterList = <font class="keyword">true</font>;}
<a name="l00179"></a><a class="code" href="classssobjects_1_1LinkedList.html#a5">00179</a>     <font class="keywordtype">void</font> <a class="code" href="classssobjects_1_1LinkedList.html#a5">clearMasterList</a>()<font class="keyword"> </font>{m_bMasterList = <font class="keyword">false</font>;}
00180 
00181     <font class="comment">//adding and removing from the list</font>
00182     <font class="comment">//note: you can't add a const item, as when stored in list as a ListNode, it is </font>
00183     <font class="comment">//  stored as void* and that breaks const rules. Also, if you retrieve a const</font>
00184     <font class="comment">//  list item, you wouldn't be able to change it's contents because of the const.</font>
00185     <font class="keywordtype">void</font> <a class="code" href="classssobjects_1_1LinkedList.html#a6">addTail</a>(T* pItem);         
00186     <font class="keywordtype">void</font> <a class="code" href="classssobjects_1_1LinkedList.html#a7">addHead</a>(T* pItem);
00187 
00188     <font class="keywordtype">void</font> <a class="code" href="classssobjects_1_1LinkedList.html#a8">empty</a>();
00189     <font class="keywordtype">void</font> <a class="code" href="classssobjects_1_1LinkedList.html#a9">purge</a>();
00190     T* <a class="code" href="classssobjects_1_1LinkedList.html#a10">removeHead</a>();
00191     T* <a class="code" href="classssobjects_1_1LinkedList.html#a11">removeTail</a>();
00192     T* <a class="code" href="classssobjects_1_1LinkedList.html#a12">removeCurrent</a>(<font class="keyword">const</font> ListDirection direction = listNEXT);
00193 
<a name="l00194"></a><a class="code" href="classssobjects_1_1LinkedList.html#a13">00194</a>     <font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> <a class="code" href="classssobjects_1_1LinkedList.html#a13">getNumEntries</a>()<font class="keyword"></font>{<font class="keywordflow">return</font> m_nNumEntries;}
00195     T* <a class="code" href="classssobjects_1_1LinkedList.html#a14">getHead</a>();
00196     T* <a class="code" href="classssobjects_1_1LinkedList.html#a15">getTail</a>();
00197     T* <a class="code" href="classssobjects_1_1LinkedList.html#a16">getNext</a>();
00198     T* <a class="code" href="classssobjects_1_1LinkedList.html#a17">getPrev</a>();
00199     T* <a class="code" href="classssobjects_1_1LinkedList.html#a18">getCurrent</a>();
00200     T* <a class="code" href="classssobjects_1_1LinkedList.html#a19">getAt</a>(<font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> index);
00201 };
00202 
00203 template &lt;class T&gt;
<a name="l00204"></a><a class="code" href="classssobjects_1_1LinkedList.html#a0">00204</a> LinkedList&lt;T&gt;::LinkedList()
00205         : m_nNumEntries(0),m_uniqueID(0),m_pHead(NULL),m_pTail(NULL),
00206           m_pCurrent(NULL),m_bMasterList(<font class="keyword">true</font>)<font class="keyword"></font>
00207 <font class="keyword"></font>{
00208 }
00209 
00210 template &lt;class T&gt;
<a name="l00211"></a><a class="code" href="classssobjects_1_1LinkedList.html#a1">00211</a> LinkedList&lt;T&gt;::~LinkedList()<font class="keyword"></font>
00212 <font class="keyword"></font>{
00213   <font class="keywordflow">if</font>(m_bMasterList)
00214     <a class="code" href="classssobjects_1_1LinkedList.html#a9">purge</a>();
00215   <font class="keywordflow">else</font>
00216     <a class="code" href="classssobjects_1_1LinkedList.html#a8">empty</a>();
00217 }
00218 
00219 <font class="comment">//</font>
00220 <font class="comment">//  Removes all nodes from the list, and deletes.</font>
00221 <font class="comment">//  the objects accociated to the node.</font>
00222 <font class="comment">//</font>
00223 template &lt;class T&gt;
<a name="l00224"></a><a class="code" href="classssobjects_1_1LinkedList.html#a9">00224</a> <font class="keywordtype">void</font> LinkedList&lt;T&gt;::purge()<font class="keyword"></font>
00225 <font class="keyword"></font>{
00226   <font class="comment">// You can only delete data pointed to by a list via a master list.</font>
00227   <font class="comment">// You should use the empty() method to clear this list.</font>
00228   assert(m_bMasterList);  <font class="comment">//see comment above</font>
00229   <font class="keywordflow">if</font>(!m_bMasterList)
00230     <a class="code" href="classssobjects_1_1LinkedList.html#a8">empty</a>();
00231 
00232   <font class="keywordflow">if</font>(m_nNumEntries)
00233   {
00234     T* o;
00235     ListNode* pNode = m_pHead;
00236     ListNode* pNext;
00237     <font class="keywordflow">while</font> (pNode)
00238     {
00239       m_nNumEntries--;
00240       pNext = pNode-&gt;m_pNext;
00241       o=static_cast&lt;T*&gt;(pNode-&gt;m_pvItem);
00242       <font class="keyword">delete</font> o;
00243       <font class="keyword">delete</font> pNode;
00244       pNode = pNext;  
00245     }
00246     m_pHead=m_pTail=m_pCurrent=NULL;
00247     m_nNumEntries=0;
00248   }
00249 }
00250 
00251 <font class="comment">//</font>
00252 <font class="comment">//  Removes all nodes from the list, and deletes.</font>
00253 <font class="comment">//  Objects are left untouched.</font>
00254 <font class="comment">//</font>
00255 template &lt;class T&gt;
<a name="l00256"></a><a class="code" href="classssobjects_1_1LinkedList.html#a8">00256</a> <font class="keywordtype">void</font> LinkedList&lt;T&gt;::empty()<font class="keyword"></font>
00257 <font class="keyword"></font>{
00258   <font class="keywordflow">if</font>(m_nNumEntries)
00259   {
00260     ListNode* pNode = m_pHead;
00261     ListNode* pNext;
00262     <font class="keywordflow">while</font> (pNode)
00263     {
00264       m_nNumEntries--;
00265       pNext = pNode-&gt;m_pNext;
00266       <font class="keyword">delete</font> pNode;
00267       pNode = pNext;  
00268     }
00269     m_pHead=m_pTail=m_pCurrent=NULL;
00270     m_nNumEntries=0;
00271   }
00272 }
00273 
00274 template &lt;class T&gt;
<a name="l00275"></a><a class="code" href="classssobjects_1_1LinkedList.html#a6">00275</a> <font class="keywordtype">void</font> LinkedList&lt;T&gt;::addTail(T* pItem)<font class="keyword"></font>
00276 <font class="keyword"></font>{
00277     assert(m_bMasterList);  <font class="comment">// you can only add data to a master list, copies are read only</font>
00278 
00279     ListNode* pTail = m_pTail;
00280     ListNode* pNode = <font class="keyword">new</font> ListNode;
00281 
00282     pNode-&gt;m_pvItem = pItem;
00283     pNode-&gt;m_id=m_uniqueID++;
00284     pNode-&gt;m_pPrev = pTail;
00285 
00286     <font class="keywordflow">if</font>(!pTail)
00287         m_pHead=pNode;
00288     <font class="keywordflow">else</font>
00289         pTail-&gt;m_pNext = pNode;
00290 
00291     m_pTail = pNode;
00292 
00293     <font class="comment">//if this is the first item in the list, make it the current item</font>
00294     m_nNumEntries++;
00295     <font class="keywordflow">if</font>(1 == m_nNumEntries)
00296       m_pCurrent = m_pTail;
00297 }
00298 
00299 template &lt;class T&gt;
<a name="l00300"></a><a class="code" href="classssobjects_1_1LinkedList.html#a7">00300</a> <font class="keywordtype">void</font> LinkedList&lt;T&gt;::addHead(T* pItem)<font class="keyword"></font>
00301 <font class="keyword"></font>{
00302     assert(m_bMasterList);  <font class="comment">// you can only add data to a master list, copies are read only</font>
00303 
00304     ListNode* pHead = m_pHead;
00305     ListNode* pNode = <font class="keyword">new</font> ListNode;
00306 
00307     pNode-&gt;m_pvItem = pItem;
00308     pNode-&gt;m_id=m_uniqueID++;
00309     
00310     <font class="comment">//setup next &amp; prev for new item</font>
00311     pNode-&gt;m_pPrev = NULL;
00312     pNode-&gt;m_pNext = pHead;
00313 
00314     m_pHead = pNode;        <font class="comment">//new head item</font>
00315     <font class="keywordflow">if</font>(!m_pTail)
00316         m_pTail=m_pHead;
00317     
00318     <font class="comment">//setup next &amp; prev for adjacent items</font>
00319 
00320     <font class="keywordflow">if</font>(pHead)
00321         pHead-&gt;m_pPrev = pNode;
00322 
00323     <font class="comment">//if this is the first item in the list, make it the current item</font>
00324     m_nNumEntries++;
00325     <font class="keywordflow">if</font>(1 == m_nNumEntries)
00326       m_pCurrent = m_pHead;
00327 }
00328 
00329 template &lt;class T&gt;
<a name="l00330"></a><a class="code" href="classssobjects_1_1LinkedList.html#a14">00330</a> T* LinkedList&lt;T&gt;::getHead()<font class="keyword"></font>
00331 <font class="keyword"></font>{
00332     <font class="keywordflow">if</font>(!m_pHead) <font class="keywordflow">return</font> NULL;
00333     T* pItem = static_cast&lt;T*&gt;(m_pHead-&gt;m_pvItem);
00334     m_pCurrent = m_pHead;
00335     <font class="keywordflow">return</font> pItem;
00336 }
00337 
00338 template &lt;class T&gt;
<a name="l00339"></a><a class="code" href="classssobjects_1_1LinkedList.html#a15">00339</a> T* LinkedList&lt;T&gt;::getTail()<font class="keyword"></font>
00340 <font class="keyword"></font>{
00341     <font class="keywordflow">if</font>(!m_pTail) <font class="keywordflow">return</font> NULL;
00342     T* pItem = static_cast&lt;T*&gt;(m_pTail-&gt;m_pvItem);
00343     m_pCurrent = m_pTail;
00344     <font class="keywordflow">return</font> pItem;
00345 }
00346 
00347 template &lt;class T&gt;
<a name="l00348"></a><a class="code" href="classssobjects_1_1LinkedList.html#a16">00348</a> T* LinkedList&lt;T&gt;::getNext()<font class="keyword"></font>
00349 <font class="keyword"></font>{
00350     <font class="keywordflow">if</font>(!m_pCurrent) <font class="keywordflow">return</font> NULL;
00351     m_pCurrent = m_pCurrent-&gt;m_pNext;
00352     <font class="keywordflow">if</font>(!m_pCurrent) <font class="keywordflow">return</font> NULL;
00353 
00354     T* pItem = static_cast&lt;T*&gt;(m_pCurrent-&gt;m_pvItem);
00355     <font class="keywordflow">return</font> pItem;
00356 }
00357 
00358 template &lt;class T&gt;
<a name="l00359"></a><a class="code" href="classssobjects_1_1LinkedList.html#a17">00359</a> T* LinkedList&lt;T&gt;::getPrev()<font class="keyword"></font>
00360 <font class="keyword"></font>{
00361     <font class="keywordflow">if</font>(!m_pCurrent) <font class="keywordflow">return</font> NULL;
00362     m_pCurrent = m_pCurrent-&gt;m_pPrev;
00363     <font class="keywordflow">if</font>(!m_pCurrent) <font class="keywordflow">return</font> NULL;
00364 
00365     T* pItem = static_cast&lt;T*&gt;(m_pCurrent-&gt;m_pvItem);
00366     <font class="keywordflow">return</font> pItem;
00367 }
00368 
00369 template &lt;class T&gt;
<a name="l00370"></a><a class="code" href="classssobjects_1_1LinkedList.html#a18">00370</a> T* LinkedList&lt;T&gt;::getCurrent()<font class="keyword"></font>
00371 <font class="keyword"></font>{
00372     <font class="keywordflow">if</font>(!m_pCurrent) <font class="keywordflow">return</font> NULL;
00373     
00374     T* pItem = static_cast&lt;T*&gt;(m_pCurrent-&gt;m_pvItem);
00375     <font class="keywordflow">return</font> pItem;
00376 }
00377 
00378 <font class="comment">//</font>
00379 <font class="comment">//RETURNS: the item you just removed</font>
00380 <font class="comment">//    </font>
00381 template &lt;class T&gt;
<a name="l00382"></a><a class="code" href="classssobjects_1_1LinkedList.html#a10">00382</a> T* LinkedList&lt;T&gt;::removeHead()<font class="keyword"></font>
00383 <font class="keyword"></font>{
00384     T* o=NULL;
00385     ListNode* pNode = m_pHead;
00386     <font class="keywordflow">if</font>(pNode)
00387     {
00388         o=static_cast&lt;T*&gt;(pNode-&gt;m_pvItem);
00389         <font class="keywordflow">if</font>(pNode-&gt;m_pNext)
00390             pNode-&gt;m_pNext-&gt;m_pPrev=NULL;
00391         m_pHead=pNode-&gt;m_pNext;
00392         <font class="keywordflow">if</font>(m_pHead==NULL)
00393             m_pTail=NULL;       <font class="comment">//nothing left on the list</font>
00394 
00395         <font class="keyword">delete</font> pNode;
00396         m_nNumEntries--;
00397     }
00398     <font class="keywordflow">return</font> o;
00399 }
00400 
00401 <font class="comment">//</font>
00402 <font class="comment">//RETURNS: the item you just removed</font>
00403 <font class="comment">//    </font>
00404 template &lt;class T&gt;
<a name="l00405"></a><a class="code" href="classssobjects_1_1LinkedList.html#a11">00405</a> T* LinkedList&lt;T&gt;::removeTail()<font class="keyword"></font>
00406 <font class="keyword"></font>{
00407     T* o=NULL;
00408     ListNode*  pNode = m_pTail;
00409     <font class="keywordflow">if</font>(pNode)
00410     {
00411         o=static_cast&lt;T*&gt;(pNode-&gt;m_pvItem);
00412         <font class="keywordflow">if</font>(pNode-&gt;m_pPrev)
00413             pNode-&gt;m_pPrev-&gt;m_pNext=NULL;
00414         m_pTail=pNode-&gt;m_pPrev;
00415         <font class="keywordflow">if</font>(m_pTail==NULL)
00416             m_pHead=NULL;       <font class="comment">//nothing left on the list</font>
00417         
00418         <font class="keyword">delete</font> pNode;
00419         m_nNumEntries--;
00420     }
00421     <font class="keywordflow">return</font> o;
00422 }
00423 
00424 <font class="comment">//</font>
00425 <font class="comment">//Removes the current node from the list, but does not free the </font>
00426 <font class="comment">//object itself. The current pointer will be moved either to the next</font>
00427 <font class="comment">//item in the list, or prev, as specified by direction.</font>
00428 <font class="comment">//</font>
00429 <font class="comment">//RETURNS: the item you just removed</font>
00430 <font class="comment">//    </font>
00431 template &lt;class T&gt;
<a name="l00432"></a><a class="code" href="classssobjects_1_1LinkedList.html#a12">00432</a> T* LinkedList&lt;T&gt;::removeCurrent(<font class="keyword">const</font> ListDirection direction)<font class="keyword"></font>
00433 <font class="keyword"></font>{
00434     ListNode* pNode = m_pCurrent;
00435 
00436     <font class="keywordflow">if</font>(!pNode)
00437         <font class="keywordflow">return</font> NULL;
00438 
00439     T* pItem = NULL;
00440     pItem = static_cast&lt;T*&gt;(m_pCurrent-&gt;m_pvItem);
00441     m_nNumEntries--;
00442     <font class="keywordflow">if</font>(!m_nNumEntries)
00443     {
00444         m_pHead=NULL;
00445         m_pTail=NULL;
00446         m_pCurrent = NULL;
00447         <font class="keyword">delete</font> pNode;
00448         <font class="keywordflow">return</font> pItem;
00449     }
00450 
00451     <font class="keywordflow">if</font> (pNode-&gt;m_pPrev)
00452     {
00453         pNode-&gt;m_pPrev-&gt;m_pNext = pNode-&gt;m_pNext;
00454         <font class="keywordflow">if</font> (pNode-&gt;m_pNext)
00455             pNode-&gt;m_pNext-&gt;m_pPrev = pNode-&gt;m_pPrev;
00456         <font class="keywordflow">else</font>
00457             m_pTail=pNode-&gt;m_pPrev;         <font class="comment">//this was the last item in the list</font>
00458     }
00459     <font class="keywordflow">else</font> 
00460     {
00461         m_pHead=pNode-&gt;m_pNext;         <font class="comment">//this was the first item in the list</font>
00462         <font class="keywordflow">if</font>(pNode-&gt;m_pNext)
00463             pNode-&gt;m_pNext-&gt;m_pPrev = NULL;
00464     }
00465     <font class="keywordflow">switch</font>(direction)
00466     { 
00467         <font class="keywordflow">case</font> listPREV: 
00468             <font class="comment">//move current pointer to the prev item. </font>
00469             m_pCurrent = pNode-&gt;m_pPrev; 
00470             <font class="keywordflow">break</font>; 
00471 
00472         <font class="keywordflow">case</font> listNEXT: 
00473             <font class="comment">//move current pointer to the next item. </font>
00474             m_pCurrent = pNode-&gt;m_pNext; 
00475             <font class="keywordflow">break</font>; 
00476 
00477         <font class="keywordflow">default</font>: assert(0); <font class="comment">//should be PREV or NEXT only</font>
00478     }
00479 
00480     <font class="keyword">delete</font> pNode;
00481     <font class="keywordflow">return</font> pItem;
00482 }
00483 
00484 template &lt;class T&gt;
<a name="l00485"></a><a class="code" href="classssobjects_1_1LinkedList.html#a19">00485</a> T* LinkedList&lt;T&gt;::getAt(<font class="keywordtype">unsigned</font> <font class="keywordtype">long</font> index)<font class="keyword"></font>
00486 <font class="keyword"></font>{
00487     <font class="keywordflow">if</font>(m_nNumEntries)
00488     {
00489         ListNode* pNode = m_pHead;
00490         ListNode* pNext;
00491                 <font class="keywordflow">while</font>(pNode)
00492         {
00493             <font class="keywordflow">if</font>(!index)
00494             {
00495                 <font class="comment">//we have reached the desired item</font>
00496                 T* pItem = static_cast&lt;T*&gt;(pNode-&gt;m_pvItem);
00497                 <font class="keywordflow">return</font> pItem;
00498             }
00499             index--;
00500             pNext = pNode-&gt;m_pNext;
00501             pNode = pNext;
00502         }
00503     }
00504     <font class="keywordflow">return</font> NULL;
00505 }
00506 
00507 };
00508 
00509 <font class="preprocessor">#endif //LINKEDLIST_H</font>
</font></pre></div><hr><address><small>Generated at Tue Sep 25 00:26:36 2001 for SimpleServerObjects by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.7 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
